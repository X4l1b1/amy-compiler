package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) => Const(i)
        case BooleanLiteral(b) => if(b) Const(1) else Const(0)
        case StringLiteral(s) => mkString(s)
        case UnitLiteral() => Const(0)
        case AmyCall(qname, args) =>
        	val funcSig = table.getFunction(qname)
        	funcSig match {
        		// Call is for a constructor
        		case None =>
        			// Get constructor
        			val constrSig = table.getConstructor(qname)
        			constrSig match {
        				case Some(ConstrSig(_,_,index))=>
		        			// Get memory variable 
		        			val memBoundary = lh.getFreshLocal()
		        			// Prepare arguments, with index for memory offset when storing
		        			val argsCode= args.map(arg => cgExpr(arg)).zipWithIndex
		        			// Allocate memory space for aguments
		        			GetGlobal(Utils.memoryBoundary) <:>
		        			SetLocal(memBoundary) <:>
		        			GetGlobal(Utils.memoryBoundary) <:>
		        			Const(4 * (args.size + 1)) <:> Add <:>
		        			SetGlobal(Utils.memoryBoundary) <:>
		        			// Store constructor index
		        			Const(index) <:> Store <:>
		        			// Store arguments with offset starting at one from index storage
		        			argsCode.map(arg => GetLocal(memBoundary) <:> Const(4 * (arg._2 + 1)) <:> Add <:> arg._1 <:> Store) <:>
		        			GetLocal(memBoundary)
        			}
        		// Call is for a function
        		case Some(FunSig(_,_,owner)) =>
        			// Handle arguments and call function
        			args.map(arg => cgExpr(arg)) <:> Call(Utils.fullName(owner, qname))
        			
        	}

        case Match(scrut, cases) =>
        	// First, get the scrut and save it to memory
        	val scrutAddr = lh.getFreshLocal()
        	val scrutCode: Code = cgExpr(scrut) <:> SetLocal(scrutAddr)
        	/**
			* Arguments :
			*	value : Code of the value to be matched by the cases
			*	case  : Pattern that has to be translated 
			* Return :
			* 	Code of the translated case and a 
			*	Map[Identifier, Int] containing the potentially updated locals table with new temp variables
        	**/
        	def matchAndBind(value: Code, caase: Pattern): (Code, Map[Identifier, Int]) = {
        		caase match {
        			case WildcardPattern	() => // if '_', value will not be used, we drop it and return 'true' 
        				(value <:> Drop <:> Const(1), locals)
        			case IdPattern(id) => // Assign value to id and return true, update locals with new variable 
        				// Get address for new variable
        				val idAddr = lh.getFreshLocal()
        				(value <:> SetLocal(idAddr) <:> Const(1), locals + (id -> idAddr))
        			case LiteralPattern(lit) => // return 'lit == value', with lit translated into code
        				(value <:> cgExpr(lit) <:> Eq, locals)
        			case CaseClassPattern(constr, args) => // construct class constructor and args Code, then check each one  using matchAndBind
        				// Get address for new constructor
        				val constrAddr = lh.getFreshLocal()
        				val ConstrSig(_, _, index) = table.getConstructor(constr).get

        				// Create code to matchAndBind arguments along with Map of new variable produced
        				val argsCode:List[(Code, Map[Identifier, Int])] = args.zipWithIndex.map(argWithIdx => matchAndBind(GetLocal(constrAddr) <:> Utils.adtField(argWithIdx._2) <:> Load, argWithIdx._1))
        				// Make each result part of the whole condition,
        				// FIX : call getFreshLocal for each argument (?)
        				val argsCondCode: Code = {
        					// if no arguments, it is true,
        					if(args.isEmpty) Const(1)
        					//   if only one argument, we just take its Code translation
        					else if(args.size == 1) argsCode.map(_._1)
        					//   if several arguments, link their translated Code with AND operator
        					//	 TODO : Du coup c'est tous les And après et on a genre une espèce de mise en abime de And ?
        					else argsCode.map(_._1) <:> args.tail.map(arg => And)
        				}

        				// Corresponds to : if(C_1 == C_2) {(v_1 == p_1) && ... && (v_n == p_n)} else 'false'
        				val allConditionsCode = value <:> SetLocal(constrAddr) <:> GetLocal(constrAddr) <:> Load <:> Const(index) <:> Eq <:> // C_1 == C_2 <=> both constr have same address 
        									  If_i32 <:> argsCondCode <:> Else <:> Const(0) <:> End

        				(allConditionsCode, locals ++ argsCode.map(_._2).flatten.toMap)
        		}


        	}

        	val casesCondCodeWithLocals: List[(MatchCase, (Code, Map[Identifier, Int]))] = cases.map(casee => (casee, matchAndBind(GetLocal(scrutAddr), casee.pat)))
        	val wrappedConditions = casesCondCodeWithLocals.map(ccase => ccase._2._1 <:> If_i32 <:> cgExpr(ccase._1.expr)(ccase._2._2, lh) <:> Else)

        	scrutCode <:> wrappedConditions <:> mkString("Match error") <:> cases.map(c => End)

        case Plus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case AmyAnd(lhs, rhs) =>
          cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
        case AmyOr(lhs, rhs) =>
          cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
        case LessThan(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case Concat(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
        case Equals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Not(b) =>
          cgExpr(b) <:> Eqz
        case Neg(i) =>
          Const(0) <:> cgExpr(i) <:> Sub
        case Ite(cond, thenn, eelse) =>
          cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:>  cgExpr(eelse) <:> End
        case Let(df, value, body) =>
          val id = df.name
          val pos = lh.getFreshLocal()
          // Specifiy updated implicit parameters
          cgExpr(value) <:> SetLocal(pos) <:> cgExpr(body)(locals + (id -> pos), lh)
        case Variable(name) => GetLocal(locals(name))
        case Sequence(head, tail) => cgExpr(head) <:> Drop <:> cgExpr(tail)         
        case Error(m) => cgExpr(m) <:> Call("Std_printString") <:> Unreachable
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
